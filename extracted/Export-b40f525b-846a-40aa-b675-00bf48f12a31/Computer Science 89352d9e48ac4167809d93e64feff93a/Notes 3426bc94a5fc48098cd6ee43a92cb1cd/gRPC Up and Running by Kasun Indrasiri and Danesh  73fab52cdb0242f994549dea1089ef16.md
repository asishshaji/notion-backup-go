# gRPC: Up and Running
by Kasun Indrasiri and Danesh Kuruppu

Class: Backend, Golang, Microservices, gRPC
Created: April 11, 2023 5:41 AM
Status: COMPLETED
Type: Book
Last edited time: May 21, 2023 11:28 AM
Person: Asish Shaji Thomas
Priority: 0

![Untitled](gRPC%20Up%20and%20Running%20by%20Kasun%20Indrasiri%20and%20Danesh%20%2073fab52cdb0242f994549dea1089ef16/Untitled.png)

- The client process calls the getProduct function in the generated stub.
- The client stub creates an HTTP POST request with the encoded message. In
gRPC, all requests are HTTP POST requests with content-type prefixed with
application/grpc.
- The remote function (/ProductInfo/getProduct) that it
invokes is sent as a separate HTTP header.
- The HTTP request message is sent across the network to the server machine.
- When the message is received at the server, the server examines the message
headers to see which service function needs to be called and hands over the message
to the service stub.
- The service stub parses the message bytes into language-specific data structures.
Then, using the parsed message, the service makes a local call to the getProduct
function.
- The response from the service function is encoded and sent back to the client.
- The response message follows the same procedure we observed on the client
side (response→encode→HTTP response on the wire); the message is unpacked
and its value is returned to the waiting client process.

![Protobuf encoded byte stream](gRPC%20Up%20and%20Running%20by%20Kasun%20Indrasiri%20and%20Danesh%20%2073fab52cdb0242f994549dea1089ef16/Untitled%201.png)

Protobuf encoded byte stream

The first part constitutes the field tag and the wire type and the Second part has the value.

The field index is the unique number we assigned to each message field when defining the message in the proto file.

The wire type is based on the field type, which is the type of data that can enter the field. 

![Untitled](gRPC%20Up%20and%20Running%20by%20Kasun%20Indrasiri%20and%20Danesh%20%2073fab52cdb0242f994549dea1089ef16/Untitled%202.png)

Once we know the field index and wire type of a certain field, we can determine the
tag value of the field using the following equation.

```jsx
tag_value = (field_index << 3) | wire_type
```

## Length-Prefixed Message Framing

Once we have the encoded data to send to the other party, we need to package the data in a way that other parties can
easily extract the information. 

In order to package the message to send over the network, gRPC uses a message-framing technique called ***length-prefix framing***.

Length-prefix is a message-framing approach that writes the size of each message before writing the message itself.

![Untitled](gRPC%20Up%20and%20Running%20by%20Kasun%20Indrasiri%20and%20Danesh%20%2073fab52cdb0242f994549dea1089ef16/Untitled%203.png)

In the above figure, the message length is specified. In gRPC communication, 4 additional bytes are allocated for each message to set its size.

The size of the message is a finite number, and allocating 4 bytes to represent the message size means gRPC communication can handle all messages up to 4 GB in size.

There is also a 1-byte compressed flag at the start of the frame which indicates whether the data is compressed or not. 

On the receipt side, once the message is received, it first needs to read the first byte to check whether the message is compressed or not. Then the receipt reads the next 4 bytes to get the size of the encoded binary message. Once the length is known, the exact length of bytes can be read from the stream

For unary/simple messages, we will have only one length-prefixed message, and for streaming messages, we will have multiple length-prefixed messages to process.

In gRPC, the request message is always triggered by the client application and it consists of three main components: request headers, the length-prefixed message, and the end-of-stream flag.

The remote call is initiated once the client sends request headers. Then, length-prefixed messages are sent in the call. 

![Untitled](gRPC%20Up%20and%20Running%20by%20Kasun%20Indrasiri%20and%20Danesh%20%2073fab52cdb0242f994549dea1089ef16/Untitled%204.png)

Finally, the EOS (end of stream) flag is sent to notify the recipient that we finished sending the request message.

The response message is generated by the server in response to the client’s request.
Similar to the request message, in most cases the response message also consists of three main components: response headers, length-prefixed messages, and trailers.

![Untitled](gRPC%20Up%20and%20Running%20by%20Kasun%20Indrasiri%20and%20Danesh%20%2073fab52cdb0242f994549dea1089ef16/Untitled%205.png)

When there is no length-prefixed message to send as a response to the client, the response message consists only of headers and trailers

## Summary

gRPC builds on top of two fast and efficient protocols called protocol buffers and HTTP/2. Protocol buffers are a data serialization protocol that is a language-agnostic, platform-neutral, and extensible mechanism for serializing structured data. Once serialized, this protocol produces a binary payload that is smaller in size than a normal JSON payload and is strongly typed. This serialized binary payload then travels over the binary transport protocol called HTTP/2.

HTTP/2 is the next major version of the internet protocol HTTP. HTTP/2 is fully multiplexed, which means that HTTP/2 can send multiple requests for data in parallel over a single TCP connection.